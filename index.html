<!DOCTYPE html>
<html>
  <head>
    <title>Pathfinding in a Tilemap Example</title>
    <link href="pathfinding.css" type="text/css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.1.1.js" integrity="sha256-16cdPddA6VdVInumRGo6IbivbERE8p7CQR3HzTBuELA=" crossorigin="anonymous"></script>
    <script src="bundle.js" type="text/javascript"></script>
  </head>
  <body>
    <h1>Pathfinding in a Tilemap</h1>
    <div class="clearfix">
      <div id="game-screen-container">
        <div id="message">Click to place <b>start</b> node</div>
      </div>
      <div id="game-data-container">
        <label for="search-method">Algorithm:</label>
        <select id="search-method">
          <option value="breadth-first">breadth-first</option>
          <option value="greedy">greedy</option>
          <option value="best-first">best-first</option>
          <option value="a-star">A*</option>
        </select>
        <button id="step">Step</button>
        <h2>Path Under Consideration</h2>
        <div id="path"></div>
        <h2>Frontier</h2>
        <div id="frontier"></div>
        <h2>Explored</h2>
        <div id="explored"></div>
      </div>
    </div>

    <h1>Instructions</h1>
    <p>
      Click the map to place the start and goal nodes.
      Then select the tree search algorithm, and click the
      <b>step</b> button to advance the search.
    </p>

    <p>
      The results of each pass through the tree search
      algorithm will be printed in the frontier and explored
      areas, respectively.  Additionally, as nodes are added
      to the frontier, they will also be marked on the map
      as yellow discs.  The numbers on the discs indicate:
      <ol>
        <li>The path cost to reach this node</li>
        <li>The straight-line distance to the goal</li>
        <li>A heuristic formed by adding these values</li>
      </ol>

    <h1>Tree Search Approaches</h1>
    <p>The algorithms this example employs are:</p>
    <p>
      <strong>Breadth-first</strong>
      The frontier is processed in the order nodes are
      expanded.
    </p>
    <p>
      <strong>Greedy</strong>
      The shortest path (in terms of movement cost) on
      the frontier is processed first.
    </p>
    <p>
      <strong>Best-first</strong>
      The path ending closest to the goal node is
      processed first.
    </p>
    <p>
      <strong>A*</strong>
      The path with the smallest path cost + distance
      to goal is processed first.  
    </p>

    <h1>Description</h1>
    <p>This pathfinding example utilizes several technologies</p>
    <h2>Tiled Map Editor</h2>
    <p>
      The <a href="http://www.mapeditor.org/">Tiled Map Editor</a> is one of the most
      popular open-source tile map editors available today.  It was used to create the
      tilemap used in this example, which is saved in the tilemaps directory as
      <a href="tilemaps/example_tilemap.tmx">example_tilemap.tmx</a>.  Tiled's native
      file format, TMX, is a custom XML extension, and as such is both human-readable
      and easily parsed.
    </p>
    <p>
      Tiled also supports exporting tilemaps as
      <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON">
        JSON (JavaScript Object Notation)
      </a>, which is a very popular serilization format and is almost identical to
      native JavaScript object declarations.  You can see the exported JSON file here:
      <a href="tilemaps/example_tilemap.json">example_tilemap.json</a>.  Compare it with
      the TMX version.
    </p>
    <p>
      While we could request and parse JSON directly from the server, because we are
      running this example from the file system, we will convert the JSON tilemap into
      a JavaScript object declaration.  We simply add an assignment:
      <code> module.exports = </code>
      to the beginning of the JSON file and resave the file with the .js extension.
      You can view the resulting JavaScript file here:
      <a href="tilemaps/example_tilemap.js">example_tilemap.js</a>
    </p>
    <h2>Browserify</h2>
    <p>
      <a href="http://browserify.org">Browserify</a> is a tool for using Node's
      package manager to bundle JavaScript files into a single bundle to be
      included in a website. In this example, that bundle is
      <a href="./bundle.js">bundle.js</a> and is build from several individual files:
      <ul>
        <li><a href="src/game.js">src/game.js</a> is the primary JavaScript file for the game</a></li>
        <li><a href="src/tilemap.js">src/tilemap.js</a> is the tilemap engine module</li>
        <li><a href="src/game.js">tilemaps/example_tilemap.js</a> contains a single tilemap's data</li>
      </ul>
    </p>
    <p>
      Note that both tilemap.js and example_tilemap.js use the module pattern, setting
      <code>module.exports</code> to a value.  In the case of tilemap.js, it is the Tilemap
      library module.  For example_tilemap.js, it is the JavaScript object representing our
      tilemap data.  We require both of these files in game.js, with the lines:<br>
      <code>
        var tilemap = require('./tilemap.js');<br>
        var tilemapData = require('../tilemaps/example_tilemap.js');<br>
      </code>
      The require function lets Browserify know that we want the contents of these
      files to be pulled into this file, and stored as the variables <code>tilemap</code>
      and <code>tilemapData</code>.
    </p>
    <p>
      We can ask Browserify to build a single JavaScript file from our source code with the command:
      <code class="terminal">
        > browserify src/game.js > bundle.js
      </code>
      This tells browserify to process game.js.  When it encounters the require functions, it
      opens and processes those files, injecting their contents into the JavaScript file it
      is building, <a href="bundle.js">bundle.js</a>, which we can then include as the only
      JavaScript file in our <a href="index.html">index.html</a> file. By packaging our code
      into a single file, we ensure that everything is loaded in the correct order and in a
      single file, while still keeping our development code in multiple files.
    </p>
    <p>
      Additionally, Browserify lets us utilize Node packages in our browser JavaScript code
      (provided we don't use any server-only functions, like file I/O).  You can also use
      <a href="https://www.npmjs.com/package/watchify">Watchify</a> to automatically
      bundle your changes as you make them.
    </p>
  </body>
</html>
